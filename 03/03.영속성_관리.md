# 3. 영속성 관리

## 3.1 엔티티 매니저 팩토리 & 엔티티 매니저

* EntityManagerFactory: 고 비용, 어플리케이션 전체에서 1개만 만들어서 공유, thread-safe
* EntityManager: 비교적 저비용, 필요할 때 마다 생성, non thread-safe



EntityManager 는 DB 연결이 꼭 필요한 시점까지 커넥션을 하지 않고, Transaction 을 시작할 때 등에 커넥션을 획득한다.



<br>



## 3.2 영속성 컨텍스트

영속성 컨텍스트란 엔티티를 영구 저장하는 환경이란 뜻이다.

엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

영속성 컨텍스트는 엔티티 매니저를 생성 시 하나가 생성된다.



<br>



## 3.3 엔티티의 생명주기

* 비영속(new): 영속성 컨텍스트와 무관계 상태
  * 엔티티 객체를 막 생성한 순수한 객체 상태. 영속성 컨텍스트나 DB 와는 전혀 연관없음
* 영속(managed): 영속성 컨텍스트에 저장된 상태
  * 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장하여 영속성 컨텍스트가 관리하는 상태
* 준영속(detached): 영속성 컨텍스트에 저장되어있다가 분리된 상태
  * 영속 상태였단 엔티티를 더 이상 영속성 컨텍스트가 관리하지 않게 된 상태
* 삭제(removed): 삭제된 상태
  * 엔티티를 영속성 컨텍스트 및 DB 에서 삭제



<br>



## 3.4 영속성 컨텍스트 특징

영속성 컨텍스트는 Entity 를 식별자 값(`@Id` 테이블의 PK 와 매핑한 값)으로 구분하기 때문에 영속 상태는 식별자 값이 반드시 필요

트랜잭션을 커밋하는 순간 flush 를 하여 영속성 컨텍스트에 새로 저장된 Entity 를 DB 에 반영함

* 영속성 컨텍스트가 엔티티를 관리할 시의 장점
  * **1차 캐시**
    * 영속 상태의 엔티티가 모두 저장되는 영속성 컨텍스트 내부의 캐시
    * 키는 `@Id` 로 매핑한 식별자, 값은 Entity instance
    * `entityManager.find()` 호출 시 1차 캐시에서 엔티티를 우선 찾고, 없으면 DB 조회
  * **동일성 보장**
    * 조회 시 1차 캐시에서 우선 조회하기 때문에 반복 호출 시에도 영속성 컨텍스트는 동일 인스턴스를 반환할 수 있음
  * **트랜잭션을 지원하는 쓰기지연**
    * EntityManager 는 트랜잭션을 커밋하기 전 까지 DB 에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 SQL 을 쌓아둠
    * 트랜잭션을 커밋 시 모아둔 쿼리를 DB 로 보내는데 이것을 트랜잭션을 지원하는 쓰기지연이라 함
    * 트랜잭션 커밋 시 EntityManager 는 영속성 컨텍스트플 flush 하여 쓰기지연 SQL 저장소에 모인 쿼리를 DB 로 전달하여 등록/수정/삭제한 Entity 를 DB 에 반영한 후 실제 DB 트랜잭션 커밋
    	* flush: 영속성 컨텍스트의 변경 내용을 DB 에 동기화하는 작업
  * **변경 감지**
  	1. 트랜잭션 커밋 -> EntityManager 내부에서 flush() 호출
  	2. Entity 와 Snapshot 을 비교해 변경된 Entity 색출
  		* 영속성 컨텍스트에 Entity 보관 시 최초 상태를 복사해 저장해 놓은 것
  	3. 변경된 Entity 존재 시 수정 쿼리 생성하여 쓰기 지연 SQL 저장소에 보관
  	4. 쓰기 지연 저장소의 SQL 을 DB로 전달
  	5. DB 트랜잭션 커밋
  	* 단, 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 Entity 에만 적용됨
  	* 또한 변경내용 적용 시 모든 필드를 업데이트함
  		* 장점
  			* 수정 쿼리가 항상 같으므로 application loading 시점에 쿼리 미리 생성 후 재사용 가능
  			* DB 에 동일한 쿼리 전송 시 DB 는 이전에 한번 파싱된 쿼리 재사용 가능
  	* `@DynamicUpdate` 를 사용해 수정된 필드만 전달할 수도 있음
  		* **일반적으로 컬러밍 30개가 넘으면 `@DynamicUpdate` 가 빠르다고 함**
  * **지연 로딩**
* 엔티티 삭제
	* 대상 엔티티 조회 후 `.remove()` 를 호출하면 SQL 저장소 쿼리 등록 -> 트랜잭션 커밋 -> flush -> 쿼리 수행 -> DB 커밋 과정으로 제거됨
	* 영속성 컨텍스트에서 제거됨
	
<br>

## 3.5 플러시

영속성 컨텍스트의 변경 내용을 DB 에 반영하는 것.


* flush 호출 시 아래와 같은 프로세스 수행
	1. 변경감지 동작
	2. 영속성 컨텍스트 내부의 모든 Entity 를 Snapshot 과 비교해 수정된 Entity 색출
	3. 수정된 Entity 가 있을 시 SQL 저장소에 수정 쿼리 등록
	4. 쓰기 지연 SQL 저장소의 쿼리를 DB 에 전송

<br>

* 영속성 컨텍스트를 flush 하는 방법은 3가지
	* `entityManager.flush()` 호출
		* 거의 안씀
	* 트랜잭션 커밋 시 자동 flush 호출
		* 트랜잭션 커밋 전 flush 를 호출해서 영속성 컨텍스트의 변경 내용을 DB 에 반영해야 하기 때문에 트랜잭션 커밋 시 flush 를 자동으로 호출하게 함
	* JPQL 쿼리 실행 시 자동 flush 호출
		* 특정 Entity 들이 영속성 컨텍스트에는 있지만 아직 DB 에 반영 안된 상태에서 JPQL 로 해당 Entity 들을 조회하려고 하면 DB 에 없으므로 값이 안 나오기 때문에 JPQL 실행 시 flush 발생
		
* 플러시 모드 옵션
	* `FlushModeType.AUTO`: 커밋이나 쿼리 실행 시 플러시 (기본값)
	* `FlushModeType.COMMIT`: 커밋할 때만 플러시 (성능 최적화 위해 사용 가능)

<br>

## 3.6 준영속

더 이상 영속성 컨텍스트로 관리되지 않는 Entity 의 상태로, 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음

* 준영속 상태로 만드는 3가지 방법
	* `entityManager.detach(entity)`: 특정 엔티티만 준영속 상태로 전환
	* `entityManager.clear()`: 영속성 컨텍스트를 완전히 초기화
	* `entityManager.close()`: 영속성 컨텍스트 종료

<br>
	
### 준영속 상태의 특장

* 거의 비영속 상태와 비슷
	* 1차캐시, 쓰기지연, 변경감지, 지연로딩 등 영속성 컨텍스트의 기능 사용 불가
* 식별자 값은 가지고 있음
	* 이미 한번 영속 상태였기 때문에 식별자 값은 반드시 존재
* 지연 로딩 불가

<br>

### 병합 (merge)

준영속/비영속 상태의 Entity 를 영속상태로 변경시키는 것

