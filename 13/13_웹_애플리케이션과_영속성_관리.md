# 13.웹 어플리케이션과 영속성 관리

## 13.1 트랜잭션 범위의 영속성 컨텍스트
### 13.1.1. 스프링 컨테이너의 기본 전략
- 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용
  - 트랜잭션 범위 == 영속성 컨텍스트의 생존 범위
  - 트랜잭션 시작 시 영속성 컨텍스트 생성하고, 트랜잭션 종료 시 영속성 컨텍스트 종료
  - 동일 트랜잭션 내에선 언제나 같은 영속성 컨텍스트에 접근함
- `@Transactional` 어노테이션을 사용하면 메서드 실행 직전에 스프링의 트랜잭션 AOP 가 우선 동작
  - 스프링 트랜잭션 AOP 는 대상 메서드 호출 직전에 트랜잭션 시작
  - 대상 메서드 정상 종료 시 트랜잭션 커밋하며 종료
    - 트랜잭션 커밋 시 JPA 는 먼저 영속성 컨텍스트를 flush -> 변경 내용을 DB 에 반영 후 DB 의 트랜잭션 커밋
  - 예외 발생 시 트랜잭션 롤백. flush 는 호출되지 않음

<br>

## 13.2 준영속 상태와 지연 로딩
- 위에서 살펴보았듯이 스프링 or J2EE 컨테이너는 트랜잭션 범위의 영속성 컨텍스트를 사용
- 트랜잭션은 보통 서비스 계층에서 시작 -> 서비스 계층이 끝나는 시점에 트랜잭션이 종료되며 영속성 컨텍스트도 함께 종료
- 따라서 조회한 엔티티가 서비스와 repository 계층에서는 영속성 컨텍스트에 관리되며 영속 상태를 유지하나, controller 나 view 같은 프레젠테이션 계층에선 준영속 상태가 됨
  - 변경 감지, 지연 로딩 기능 사용이 어려움
  - 변경 감지의 경우 프레젠테이션 계층에선 별 문제가 되지 않으나, 지연로딩이 되지 않는것이 제일 큰 문제
  - 준영속 상태의 지연 로딩을 해결하는 방법은 크게 2가지
    1. **뷰가 필요한 엔티티를 미리 로딩: 글로벌 페치 전략 수정, JPQL 페치 조인, 강제 초기화**
    2. **OSIV 를 사용해 엔티티를 항상 영속 상태로 유지**

<br>

### 13.2.1. 글로벌 페치 전략 수정
- 글로벌 페치 전략을 지연 로딩에서 즉시 로딩으로 수정하면 되는 가장 간단한 방법
  ```java
  @ManyToOne(fetch = FetchType.EAGER)
  private Member member;
  ```
- 단점
  - 사용하지 않는 엔티티를 로딩함
  - N + 1 문제 발생!
    - JPA 가 JPQL 을 분석해 SQL 생성 시 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용 -> 즉시 / 지연 로딩 구분 없이 SQL 생성
    - 처음 조회한 데이터 수 만큼 다시 SQL 을 사용해 조회하게 됨
    - 이는 JPQL 페치 조인으로 해결 가능

<br>

### 13.2.2 JPQL 페치 조인
- JPQL 을 호출하는 시점에 함께 로딩할 엔티티를 선택 가능
- join 명령어 마지막에 fetch 를 추가하면 됨
- 페치 조인을 사용하면 SQL JOIN 을 사용해 페치 조인 대상까지 함께 조회하므로 n+1 문제 안 일어남
  - 연관된 엔티티를 이미 로딩했으므로 글로벌 페치 전략은 무의미
  
```jpaql
// 페치 조인 사용 전
// JPQL
select o from Order o

// SQL
select * from Order

// 페치 조인 사용 후
// JPQL
selecgt o
from Order o
join fetch o.member

// SQL
select o.*, m.*
from Order o
join Member m on o.MEMBER_ID = m.MEMBER_ID
```

- 단점
  - 무분별하게 사용시 화면에 맞춘 repository method 가 증가할 수 있음 -> 프레젠테이션 계층이 데이터 접근 계층을 침범하는 꼴

<br>

### 13.2.3. 강제 초기화
- 영속성 컨텍스트가 살아있을 때 프레젠테이션 계층에 필요한 엔티티를 강제로 초기화 하여 반환하는 방법
```java
@Transactional
public Order findOrder(String id) {
	// 지연 로딩 상황을 가정 -> 프록시 객체 사용
	Order order = OrderRepoistory.findOrder(id);
	order.getMember().getName(); // 프록시 객체를 강제로 초기화
	return order;
}
```

- 위처럼 프록시를 초기화하는 역할을 서비스 계층이 담당하면 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 함
- 이는 결국 프레젠테이션 계층이 서비스 계층 침범하는 꼴이 됨
- 따라서 비즈니스 로직을 담당하는 서비스 계층에서 프레젠테이션 계층을 위한 프록시 초기화 역할의 분리 필요
- FACADE 계층이 해당 역할 수행

<br>

### 13.2.4. FACADE 계층 추가
- 프레젠테이션 계층과 서비스 계층 사이에 추가 계층을 두어 논리적 의존성 분리
- 프록시를 초기화하려면 영속성 컨텍스트가 필요 -> FACADE 에서 트랜잭션 시작
- FACADE 계층의 역할과 특징
  - 프레젠테이션 계층과 도메인 모델 계층 간 논리적 의존성 분리
  - 프레젠테이션 계층서 필요한 프록시 객체 초기화
  - 서비스 계층을 호출해 비즈니스 로직 실행
  - Repository 를 직접 호출해 뷰가 요구하는 엔티티 탐색
```java
class OrderFacade {
	@Autowired
	private OrderService orderService;
	
	public OrderService findOrder(String id) {
		Order order = orderService.findOrder(id);
		// 프레젠테이션 계층서 필요한 프록시 객체를 강제 초기화
		order.getMember().getName();
		return order;
	}
}

class OrderService {
	public Order findOrder(String id) {
		return orderRepository.findOrder(id);
	}
}
```

- 단점
  - 중간에 추가적인 계층이 생기게 되므로 추가 코드 작성이 필요하게 됨

<br>

## 13.3 OSIV
- OpenSessionInView (OSIV) 는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻 -> 뷰에서도 지연 로딩이 가능해짐

<br>

### 13.3.1. 과거 OSIV: 요청 당 트랜잭션
- 클라이언트 요청 들어오자마자 서블릿 필터나 스프링 인터셉터에스 트랜잭션 시작 후 요청이 끝날 때 트랜잭션도 종료
- 그러나 컨트롤러나 뷰 같은 프레젠테이션 계층이 엔티티를 변경할 수 있다는 문제 존재
  - 아래와 같은 방법으로 방지
    - 엔티티를 읽기 전용 인터페이스로 제공
    - 엔티티 래핑
    - DTO 만 반환
- 옛날 방식으로 요새는 잘 안씀

<br>

### 13.3.2. 스프링 OSIV: 비즈니스 계층 트랜잭션
- 제공 필터 / 인터셉터 종류
  - 필터: 하이버네이트 OSIV 서블릿 필터, JPA OEIV 서블릿 필터
  - 인터셉터: 하이버네이트 OSIV 스프링 인터셉터, HPA OEIV 스프링 인터셉터
- 동작 원리
  1. 클라이언트 요청 인입 시 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트 생성. 단, 트랜잭션을 시작하진 않음
  2. 서비스 계층서 @Transactional 로 트랜잭션 시작 시 위에서 미리 생성한 영속성 컨텍스트를 찾아와서 트랜잭션 시작
  3. 서비스 계층 종료시 트랜잭션 커밋 & 영속성 컨텍스트 플러시 -> 이 때 트랜잭션은 끝나나 영속성 컨텍스트는 유지
  4. 컨트롤러와 뷰 까지 영속성 컨텍스트가 유지되므로 조회 엔티티는 영속 상태 유지
  5. 서블릿 필터나 스프링 인터셉터로 요청 인입 시 영속성 컨텍스트 종료 -> 플러시 호출 없이 바로 종료
- 트랜잭션 없이 읽기
  - 영속성 컨텍스트를 통한 모든 변경은 트랜잭션 내에서 이뤄져야 함
  - 단, 변경 없는 단순 조회는 트랜잭션이 없어도 되는데 이를 트랜잭션 없이 읽기 라 하며, 프록시를 초기화하는 지연 로딩도 조회 기능이므로 트랜잭션 없이 읽기가 가능
- 스프링 OSIV 특징
  - 영속성 컨텍스트를 프레젠테이션 계층까지 유지
  - 프레젠테이션 계층에는 트랜잭션이 없으므로 엔티티 수정 불가
  - 프레젠 테이션 계층에는 트랜잭션은 없지만 트랜잭션 없이 읽기를 사용해 지연 로딩 가능
- 스프링 OSIV 주의사항
  - 프레젠테이션 계층에서 **엔티티를 수정한 직후에 트랜잭션 시작하는 서비스 계층**을 호출하면 문제 발생
    - 트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하여 해결 가능
  - 스프링 OSIV 는 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있으므로 발생할 수 있는 문제

<br>

### 13.3.3. OSIV 정리
- 스프링 OSIV 의 특징
  - OSIV 는 클라이언트 요청 인입 시 영속성 컨텍스트 생성 후 요청 종료까지 같은 영속성 컨텍스트를 유지 -> 한번 조회한 엔티티는 요청 종료까지 영속 상태 유지
  - 엔티티 수정은 트랜잭션 있는 계층에서만 동작 가능 -> 트랜잭션이 없는 프레젠테이션 계층은 지연 로딩을 포함해서 조회만 가능
- 스프링 OSIV의 단점
  - 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있음에 주의
  - 프레젠테이션 계층서 엔티티 수정 이후 비즈니스 로직을 수행하면 엔티티 수정될 수 있음
  - 프레젠테이션 계층서 지연 로딩에 의한 SQL 이 실행되므로 성능 튜닝 시 확인해야 할 부분 넓음
- OSIV vs FACADE vs DTO
  - OSIV 를 안쓰면 결국 준영속 상태 되기 전 강제 프록시 초기화를 하거나, 엔티티 직접 노출하지 않고 엔티티와 거의 유사한 DTO 를 만들어 반환하는 것인데 전부 OSIV 에 비해 낭비가 큼
- OSIV 가 만능은 아님
  - 화면 출력시 엔티티 유지하며 객체 그래프 자유 탐색이 가능하나 통계 등의 복잡한 데이터에 대해선 필요한 데이터들만 조회하여 DTO 로 반환하는게 더 유리할 수도 있음
- OSIV 는 같은 JVM 을 벗어난 원격 상황에선 사용 불가
